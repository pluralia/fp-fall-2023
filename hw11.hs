
-------------------------------------------------------------------------------

-- 1. Какие из выражений ниже находятся в слабой головной нормальной форме (WHNF),
--    но не в номальной форме (NF)? Почему? (1,5 балла)

-- Подсказка: выражение undefined находится не в NF:
--            оно может быть вычислено до прерывания программы с сообщением "*** Exception: Prelude.undefined"

    -- (+) (2 * 3 * 4)

    -- [undefined, 4 + 5, -1]

    -- (,) undefined

    -- 3

    -- fst (1,0)

    -- \x -> x

-------------------------------------------------------------------------------

-- 2. Распишите вычисление `value` в thunk'ах (1 балл)

value :: Integer
value = foo (3 * 10) (5 - 2)
  where
    foo :: Num p => p -> p -> p
    foo a b = bar a a (a + b)

    bar :: Num a => a -> a -> p -> a
    bar x y z = x + y

-------------------------------------------------------------------------------

-- 3. Какие из нижеперечисленных функций не могут привести к расходимости (неостановке вычисления)? Почему? (2 балла)

wow :: p -> p
wow a = a

con :: b -> p -> p
con = const wow

bazz :: p -> b -> Bool
bazz x = const True

qux :: t
qux = let x = x in x

corge :: String
corge = "Sorry, my value was changed"

grault :: (Eq a, Num a) => p -> a -> p
grault x 0 = x
grault x y = x

garply :: Integer -> Char
garply = grault 'q'

waldo :: p -> p
waldo = wow

-------------------------------------------------------------------------------

-- 4. BangPatterns  (0,5 балла)
--    Реализуйте `foldl'`, форсировав вычисление с помощью ! аналогично `sumBang` из лекции

-------------------------------------------------------------------------------

-- 5. `seq` (2 балла)

-- Помимо ! есть и другие способы форсировать вычисление.
-- Например, если вы хотите вычислить значение перед передачей его в функцию, можно использовать `seq` 
-- https://hackage.haskell.org/package/ghc-prim-0.11.0/docs/GHC-Prim.html#v:seq

-- `seq` принимает 2 аргумента, вычисляет первый до WHNF и возвращает второй

-- Как использовать? Пример с foldl':
-- https://hackage.haskell.org/package/base-4.19.0.0/docs/src/Data.Foldable.html#foldl%27
-- Здесь есть следующий код: z `seq` k (f z x).
-- В этом случае первый аргумент `seq` -- z, и z будет вычислено до WHNF,
-- а затем он будет использоватся при вычислении второго аргумента -- k (f z x).
-- Результат вычисления второго аргумента -- результат всего `seq`

-- Практикуемся: rде поможет seq?
-- При вычислении каких из перечисленных ниже функций использование seq предотвратит
-- нарастание количества невычисленных выражений при увеличении значения первого аргумента?
-- Объясните свой ответ

foo :: (Eq a, Num a, Num t) => a -> t -> t
foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'

bar :: (Eq t1, Num t1) => t1 -> (t1 -> t2) -> t1 -> t2
bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'

baz :: (Eq t, Num t, Num a) => t -> (a, a) -> a
baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

quux :: (Eq t, Num t, Num a) => t -> (a, a) -> a
quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p

-------------------------------------------------------------------------------

-- 6. $! (1 балл)

-- Вдобавок к ! и `seq` есть $!. Он нужен, чтобы вычислить значение перед передачей его в функцию.
-- Несложно заметить, что он напоминает $ -- оператор применения.
-- $! -- строгую версию $, вычисляющую аргумент до WHNF перед передачей его в функцию

-- Ниже определены функции mySum и goSum. Ответьте на вопросы об их вычислении

mySum :: (Eq a, Num a) => (a, ()) -> a -> (a, ())
mySum acc 0 = acc

---------------------------------------

-- 6.a Почему Haskell говорит здесь, что $! -- redundant?
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

goSum :: Integer -> (Integer, ())
goSum = mySum (0, ())

---------------------------------------

-- 6.b Будут ли накапливаться отложенные вычисления в первом аргументе функции mySum?
--    Да или нет и почему?

---------------------------------------

-- 6.c Будут ли накапливаться отложенные вычисления во втором аргументе функции mySum?
--    Да или нет и почему?

-------------------------------------------------------------------------------

-- 7*. Почему здесь происходит утечка памяти? Как ее исправить? (2 балла)

-- let small' = fst (small, large) in ... small' ...

-------------------------------------------------------------------------------
