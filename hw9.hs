import           Control.Monad.Writer.Lazy
import           Control.Monad.Reader
import           Control.Monad.State.Lazy
import qualified Data.Map.Strict as M
import qualified System.Random as R -- cabal install --lib  random

-------------------------------------------------------------------------------

-- 1. Writer: Брандмауэр (3 балла)

--    Напишите очень простой брандмауэр: он фильтрует пакеты на основе базы правил,
--    соответствующих IP-адресам отправителя и получателя.
--    Основная задача брандмауэра -- фильтрация пакетов, но мы хотели бы, чтобы он также вел
--    журнал своей работы (логи)

-- | Формат логов
--
data Entry = Log {
      count :: Int     -- количество таких сообщений подряд, идущих друг за другом
    , msg   :: String  -- сообщение
    } deriving Eq

-- | Добавляет сообщение в лог
--
logMsg :: String -> Writer [Entry] ()
logMsg s = tell [Log 1 s]

-- | Задайте тип, выражающий IP-адрес
--
data IP = YourDefinition
  deriving (Show, Eq)

data Action = Accept | Reject
  deriving (Show, Eq)

data Rule = Rule {
      action :: Action
    , source :: IP
    , destination :: IP
    } deriving (Show, Eq)

data Packet = Packet {
      pSource :: IP
    , pDestination :: IP
    } deriving (Show, Eq)

-- | Возвращает первое правило, действующее на пакет
--
match :: [Rule] -> Packet -> Maybe Rule
match = undefined

-- | Фильтрует 1 пакет
--   В логе должны быть сообщения 2 видов:
--      1) Нет правила для пакета (указать пакет)
--      2) Есть правило для пакета (указать пакет и правило)
-- 
filterOne :: [Rule] -> Packet -> Writer [Entry] (Maybe Packet)
filterOne = undefined

-- Немного усложним задачу: теперь мы хотим объединить дублирующиеся последовательные записи в журнале.
-- Ни одна из существующих функций не позволяет изменять результаты предыдущих этапов вычислений,
-- но мы можем использовать прием "отложенного протоколирования", чтобы добавлять запись в лог только
-- после получения новой записи, которая не совпадает с предыдущими.

-- | Объединяет одинаковые записи в конце лога
  -- Эта функция использует [Entry] и в качестве типа лога, и в качестве типа результата.
  --   - При объединении двух одинаковых сообщений результатом будет только сообщение с увеличенным счетчиком,
  --     при этом в лог ничего не добавляется
  --   - При объединении двух разных сообщений, первое записывается в лог, а второе возвращается в качестве результата
  --     (мы запишем второе сообщение в лог, когда-нибудь потом -- когда придет новое сообщение, отличное от него --
  --     в этом и есть суть "отложенного протоколирования")
--
mergeEntries :: [Entry] -> [Entry] -> Writer [Entry] [Entry]
mergeEntries = undefined

-- | Применяет функцию fn к каждому значению из списка xs, чтобы получить список Writer.
--   Затем запускает каждый Writer и объединяет логи c помощью merge, используя initial в качестве начального лога.
--   Результатом работы функции является Writer, значение которого -- список всех значений из всех Writer,
--   а лог -- результат слияния всех логов всех Writer.
--
-- | Для нашего брандмауэра:
--     1) xs -- список пакетов
--     2) fn -- функция, производящая Writer из пакета
--     3) initial -- начальный лог
--     4) merge -- функция, которая мержит 2 лога в один и производит из этого Writer
--
groupSame :: (Monoid a) => a -> (a -> a -> Writer a a) -> [b] -> (b -> Writer a c) -> Writer a [c]
groupSame initial merge xs fn = undefined

-- | Фильтрует список пакетов и возвращает список отфильтрованных пакетов и логи
--   В начале и конце обработки пакетов добавьте сообщения о начале и конце логирования
--   Используйте groupSame
--
filterAll :: [Rule] -> [Packet] -> Writer [Entry] [Packet]
filterAll = undefined

-------------------------------------------------------------------------------

-- 2. Reader: Инстанцирование шаблонов (2 балла)

-- Рассмотрим проблему инстанцирования шаблонов, содержащих подстановки переменных и включенные шаблоны.

-- Пример проблемы из TypeScript:
--   const y = 32;
--   const x = `I want "${y}" apples.`;
-- ожидаем, получить в x строку "I want 32 apples."

-- Используя монаду Reader, мы можем поддерживать окружение/контекст всех известных шаблонов и всех известных переменных.
-- Когда встречается подстановка переменной, мы можем использовать функцию asks для поиска значения переменной в окружении.
-- Если в шаблон включены определения новых переменных, мы будем должны изменить окружение, добавив в него эти перменные;
-- продолжить работу на измененном окружении можно с помощью функции local

-- | Зададим тип шаблона
--
data Template = Text String
              | Var Template
              | Quote Template
              | Include Template [Definition]
              | Compound [Template]
  deriving (Show, Eq)

data Definition = Definition Template Template
  deriving (Show, Eq)

-- | Окружение -- это имя шаборна в шаблон и имя переменной в переменную
--
data Environment = Env {
      templs :: M.Map String Template
    , vars   :: M.Map String String
    } deriving (Show, Eq)

-- | Ищет переменную в окружении
--
lookupVar :: String -> Environment -> Maybe String
lookupVar = undefined

-- | Ищет шаблон в окружении
--
lookupTemplate :: String -> Environment -> Maybe Template
lookupTemplate = undefined

-- | Добавляет новые переменные в окружение
-- 
addDefs :: M.Map String String -> Environment -> Environment
addDefs = undefined

-- | Резолвит (подставляет все неизвестные) определение
--   и выдает в качестве ответа пару (имя переменной, значение)
--
resolveDef :: Definition -> Reader Environment (String, String)
resolveDef = undefined

-- | Резолвит (подставляет все неизвестные) шаблон в строку
--     Пример использования:
--     ts = Compound [Text "I want ", Var . Text $ "y", Text " apples."]
--     mapM resolve ts ->  ["I want ", "32", " apples."]
--
-- Подсказки:
-- 1) Quote -- штука, аналогичная Var, но для шаблонов -- нужно зарезолвить входящий шаблон до имени, а потом поискать его в environment
-- 2) Include -- здесь необходимо зарезолвить шаблон templ с учетом определений defs. Для этого необходимо:
--    a. Получить имя шаблона через resolve templ
--    b. Найти тело шаблона по его имени в environment
--    с. Если тела не нашлось, то вернуть "", а если нашлось -- зарезолвить defs, обновить ими environment, и на новом environment зарезолвить тело
-- 3) Compound -- здесь могут пригодиться `traverse` и `mconcat`
--
resolve :: Template -> Reader Environment String
resolve = undefined


-- | Пример использования
--
test :: String
test = runReader (resolve template) $ Env M.empty (M.fromList [("y", "32")])
  where
    template :: Template
    template = Compound [Text "I want ", Var . Text $ "y", Text " apples."]

-------------------------------------------------------------------------------

-- 3. State: Генерация случайного значения кастомного типа (1 балл)

-- Чистый функциональный язык не может обновлять значения на месте (почему?)
-- Распространенной идиомой для имитации таких вычислений с сохранением состояния является
-- "прохождение" параметра состояния через последовательность функций
-- Рассмотрим пример

data MyType = MT Int Bool Char Int
  deriving Show

-- Чтобы запустить: `makeRandomValue (mkStdGen 23)`

makeRandomValue :: R.StdGen -> (MyType, R.StdGen)
makeRandomValue g =
    let (n,g1) = R.randomR (1, 100) g
        (b,g2) = R.random g1
        (c,g3) = R.randomR ('a', 'z') g2
        (m,g4) = R.randomR (-n, n) g3
    in (MT n b c m, g4)

-- Этот подход работает, но такой код сложен в сопровождении, может содержать ошибки и быть грязным (что делает его грязным?)
-- Монада State скрывает потоковую передачу состояния (как вы понимаете слова "потоковая передача состояния") внутри операции >>=,
-- делая код проще для написания, чтения и модификации.


-- | Возвращает случайное значение и обновляет состояние генератора случайных чисел
--
getAny :: (R.Random a) => State R.StdGen a
getAny = undefined

-- | Аналогична getAny, но генерирует значение в границах
--
getOne :: (R.Random a) => (a, a) -> State R.StdGen a
getOne bounds = undefined

-- | Используя монаду State с StdGen в качестве состояния, мы можем генерировать случаные значения
--   заданного типа, не передавая состояния генератора случайных чисел в коде вручную
--
makeRandomValueST :: R.StdGen -> (MyType, R.StdGen)
makeRandomValueST = undefined

-------------------------------------------------------------------------------

-- 4. "Императивное" программирование (2 балла)

---------------------------------------

-- | 4.a Реализуйте функцию `whileM_`, исполняющую заданное вычисление,
--        пока первое вычисление возвращает 'True'
--
whileM_ :: m Bool -> m a -> m ()
whileM_ = undefined

---------------------------------------

-- | 4.b Реализуйте функцию `forM_`, являющуюуся аналогом цикла for.
--        Перед входом в цикл вычисляется init, в итерациях цикла вычисляется body, 
--        в конце каждой итерации цикла вычисляется nextIter, итерации идут, 
--        пока выполняется условие cond
--
forM_ :: (m (), m Bool, m ()) -> m a -> m ()
forM_ (init, cond, nextIter) body = undefined

---------------------------------------

-- | Окружение / контекст: имя переменной в значение
--
type Context = M.Map String Int

-- 4.c Реализуйте следующие функции

-- | Задаёт значение переменной. 
--   Если переменная есть в контексте, перезаписывает её значение.
--
setVar :: String -> Int -> State Context ()
setVar = undefined

-- | Увеличивает значение переменной. 
--   Если её нет в контексте, то кидает ошибку.
--
incVar :: String -> Int -> State Context ()
incVar = undefined

-- | Достаёт из контекста значение заданной переменной.
--   Если переменной нет в контексте, то кидает ошибку.
--
getVar :: String -> State Context Int
getVar = undefined

---------------------------------------

-- 4.d Перепешите один в один (насколько это возможно) представленный ниже плюсовый код, 
--      используя монаду 'State' и функции, которые вы реализовали выше. 
--      Напишите 3 теста, проверяющие, что ваша реализация работает корректно

{- 
int fib(int n) {
    int prev = 0;
    int cur = 1;

    for (int i = 0; i < n; i = i + 1) {
        int c = cur;
        cur = prev + cur;
        prev = c;
    }

    return cur
} 
-}

fib :: Int -> State Context Int
fib = undefined

-------------------------------------------------------------------------------

-- 5*. State и Either (2 балла)
--     Создайте свою монаду StateWithError, обладающую сразу двумя эффектами:
--      a) эффектом монады 'State'  (изменяемое состояние);
--      b) эффектои монады 'Either' (возможность завершения вычисления ошибкой)

-- | Задайте тип
--
data StateWithError = YourImplementation

-- Реализуйте инстанс Monad для StateWithError

-- Привидите пример использования

-------------------------------------------------------------------------------
