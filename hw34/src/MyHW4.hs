{-# LANGUAGE OverloadedStrings #-}
module MyHW4 where

import qualified Data.Map.Strict as M
import qualified Data.Text       as T
import qualified Data.Vector     as V
import qualified Data.List as L (foldl')
import qualified Data.Set as S

-- К каждой задаче приведите хотя бы 1 или 2 тестовых примера.
-- Подсказка: Text и Vector можно конкатенировать с помощью оператора '<>'.
--
-- Старайтесь чтобы код был читаемым, используете понятные имена переменных, блоки where и
-- красивое форматирование.
--
-- Условие "за один проход" означает, что сложность итого алгоритма должна быть не больше O(n).
--
-- Бонус: запишите решения в стиле point free там где это возможно и __не портит читаемость__
-- (до +1 балла к стандартным 10)
--
-- Многие из заданий напоминают то, что мы регулярно делаем в Biocad.

------------------------------------------------------------------------------------------------

-- 1. Дополнение нулями слева (0,5 балла)
--
-- Готовую функцию из пакета text использовать нельзя

padZero :: T.Text -> Int -> T.Text
padZero str width = T.replicate (width - T.length str) "0" <> str

-- Эта функция работает за O(n), потому что
-- T.length ~ O(n), T.replicate ~ O(n), <> ~ O(n)

------------------------------------------------------------------------------------------------

-- 3. Четные и нечетные (0,5 балла)
--
-- Разделить список на подсписки элементов на четных и нечетных позициях используя свертку. Порядок элементов
-- должен сохраняться.

evenodd :: [a] -> ([a], [a])
evenodd [] = ([], [])
evenodd xs = foldr f ([], []) $ zip xs [0..]
 where
  f :: (a, Int) -> ([a], [a]) -> ([a], [a])
  f (x, idx) (even1, odd1) = if even idx then (x : even1, odd1) else (even1, x : odd1)

-- Для удобного сохранения порядка воспользуемся foldr
------------------------------------------------------------------------------------------------

-- 4. Среднее (0,5 балла)
--
-- Посчитать среднее значение чисел в массиве с помощью свёртки за один проход

average :: V.Vector Double -> Double
average v = fst $ V.foldl' cntMean (0, 0) v
  where
    cntMean :: (Double, Double) -> Double -> (Double, Double)
    cntMean (m, idx) el = ((m * idx + el) / (idx + 1), idx + 1)

------------------------------------------------------------------------------------------------

-- 5. GC состав (0,75 балла)
-- Нуклеотиды G и C физически чем-то отличаются от нуклеотидов A и T, поэтому их доля в последовательности — важная характеристика.
--
-- Посчитать долю G/C в последовательности с помощью свёртки за один проход.

gcContent :: T.Text -> Double
gcContent str | T.length str == 0 = error "Empty sequence!"
              | otherwise         = T.foldl' cntGC 0 str / fromIntegral (T.length str)

cntGC :: Double -> Char -> Double
cntGC cnt ch = if ch == 'G' || ch == 'C' then cnt + 1 else cnt
 
-----------------------------------------------------------------------------------------------

-- 9. M.fromList (0,75 балл)
--
-- Реализовать `M.fromList :: [(k, v)] -> M.Map k v` с помощью свёрток `foldl'` и `foldr`. Объяснить
-- чем будет отличаться поведение этих вариантов.

fromListL :: Ord k => [(k, v)] -> M.Map k v
fromListL = L.foldl' (\acc (k, v) -> M.insert k v acc) M.empty

fromListR :: Ord k => [(k, v)] -> M.Map k v
fromListR = foldr (\(k, v) acc -> M.insert k v acc) M.empty


-- foldl добавляет элементы в словарь проходясь слева-направо -> если ключи дублируются, то
-- в итоговый словарь попадет наиболее поздняя пара ключ-значение из исходного списка
--
-- foldr добавляет элементы справа-налево -> если ключи дублируются, то в итоговый словарь 
-- попадет наиболее ранняя пара ключ-значение из исходного списка
--
-- Вывод: foldl позволяет получить результат в точности как у M.fromList

------------------------------------------------------------------------------------------------

-- 10. Уникальные элементы (0,5 балла)
--
-- Оставить только уникальные элементы из списка. Порядок может измениться.
--
-- Для решения этой задачи можно использовать Map или тип Set из пакета containers:
-- https://hackage.haskell.org/package/containers-0.7/docs/Data-Set.html
--
-- Решение должно использовать свёртку по входному списку в один проход. Использовать fromList нельзя.

nubOrd :: Ord a => [a] -> [a]
nubOrd = S.toList . foldr S.insert S.empty

------------------------------------------------------------------------------------------------

-- 11. Сложная: query parameters (1,25 балл)
--
-- В схеме URL могут использоваться query parameters: http://some.come/foo?a=1&b=2&c=hello
--
-- Соберите строку "a=1&b=2&c=hello" из `Map Text Text` используя `foldlWithKey'` или `foldrWithKey`.

buildQuery :: M.Map T.Text T.Text -> T.Text
buildQuery p = T.intercalate "&" (M.foldrWithKey' (\k v acc -> T.intercalate "=" [k, v] : acc) [] p)